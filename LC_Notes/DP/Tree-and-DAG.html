<div class="break-words"><div><div class="FN9Jv WRmCx"><h4 id="representing-problems-as-dag">Representing problems as DAG</h4>
<p>Any dynamic programming problem can be represented as a <strong>directed acyclic graph</strong>. In such a graph, each node corresponds to a dynamic programming state and the edges indicate how the states depend on each other.</p>
<p>As an example, consider the problem of forming a sum of money n using coins{c1,c2, . . . ,ck}. In this problem, we can construct a graph where each node corresponds to a sum of money, and the edges show how the coins can be chosen.For example, for coins{1,3,4} and n=6, the graph is as follows:<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/cb9a3aba-fda6-44ec-911c-461f661933b1_1626594489.044929.png"/><br/></p>
<p>Using this representation, the shortest path from node 0 to node n corresponds to a solution with the minimum number of coins, and the total number of pathsfrom node 0 to node n equals the total number of solutions.</p>
<p><strong>Successor paths</strong><br/>
In successor graphs,the outdegree of each node is 1, i.e., exactly one edge starts at each node.  A successor graph consists of one or more components, each of which contains one cycle and some paths that lead to it.<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/f82d7df8-b4d1-4c86-ae02-2e9f25337fed_1626601464.4817998.png"/><br/>Since<strong>each node of a successor graph has a unique successor</strong>, we can also define a function succ(x,k) that gives the node that we will reach if we begin at node x and walk k steps forward. For example, in the above graph succ(4,6)=2,because we will reach node 2 by walking 6 steps from node 4:<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/d6c65098-e988-4c01-bdff-e9a204acee12_1626601551.4209154.png"/><br/>A straight forward way to calculate a value of succ(x,k) is to start at node x and walk k steps forward, which takes O(k) time. However, using preprocessing,any value ofsucc(x,k) can be calculated in only O(logk) time.The idea is to precalculate all values of succ(x,k) where k is a power of two and atmost u, where u is the maximum number of steps we will ever walk. This can be efficiently done, because we can use the following recursion:<img alt="image" src="https://assets.leetcode.com/users/images/dc728c91-362e-4c69-af86-be1de4fad695_1626601591.0602462.png"/><br/>Pre-calculating the values takes O(nlogu) time, becauseO(logu) values are calculated for each node. In the above graph, the first values are as follows:<img alt="image" src="https://assets.leetcode.com/users/images/462e8f9c-5e40-40fd-bba4-64150d069e6d_1626601617.4108417.png"/><br/></p>
<p>Table size will be of size [n][ceil(logk)] ( k = 10^7 we only need 24 columns).</p>
<p>After this, any value of succ(x,k) can be calculated by presenting the numberof steps k as a sum of powers of two.  For example, if we want to calculate thevalue of succ(x,11), we first form the representation 11=8+2+1. Using that<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/02ee6d40-7b50-4707-a5e4-0ec9358c534d_1626601654.963669.png"/><br/>Such a representation always consists of O(logk) parts, so calculating a value of succ(x,k) takes O(logk) time.</p>
<p><strong>Finding ancestors</strong><br/>
What is the kth ancestor of a node?<br/>
<a href="https://leetcode.com/problems/kth-ancestor-of-a-tree-node/" target="_blank">https://leetcode.com/problems/kth-ancestor-of-a-tree-node/</a></p>
<p>Let ancestor(x,k) denote the kth ancestor of a node x( or -1 if no ancestor exits).</p>
<ul>
<li>An easy way to calculate any value ofancestor(x,k) is to perform a sequence of k moves in the tree. The time complexity of this approch is O(k).</li>
<li>Any value of ancestor(x,k) can be efficiently calculated in O(logk) time after preprocessing( preprocessing takes O(nlogn) time).The idea is to precalculate all values ancestor(x,k) wherek≤n is a power of two.</li>
</ul>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">class</span><span> </span><span class="token">TreeAncestor</span><span> </span><span class="token">{</span><span>
</span></span><span><span></span><span class="token">public</span><span class="token">:</span><span>
</span></span><span>    
</span><span><span>    vector</span><span class="token">&lt;</span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;&gt;</span><span>par</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> maxDepth</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> size</span><span class="token">;</span><span>
</span></span><span>    
</span><span><span>    </span><span class="token">TreeAncestor</span><span class="token">(</span><span class="token">int</span><span> n</span><span class="token">,</span><span> vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span class="token">&amp;</span><span> parent</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>        maxDepth</span><span class="token">=</span><span class="token">(</span><span class="token">ceil</span><span class="token">(</span><span class="token">(</span><span class="token">log</span><span class="token">(</span><span>n</span><span class="token">)</span><span class="token">)</span><span class="token">/</span><span class="token">(</span><span class="token">log</span><span class="token">(</span><span class="token">2</span><span class="token">)</span><span class="token">)</span><span class="token">)</span><span class="token">)</span><span class="token">+</span><span class="token">1</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">int</span><span> size</span><span class="token">=</span><span>parent</span><span class="token">.</span><span class="token">size</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>        par</span><span class="token">.</span><span class="token">resize</span><span class="token">(</span><span>maxDepth</span><span class="token">,</span><span class="token generic-function">vector</span><span class="token generic-function generic">&lt;</span><span class="token generic-function generic">int</span><span class="token generic-function generic">&gt;</span><span class="token">(</span><span>size</span><span class="token">,</span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> i</span><span class="token">=</span><span class="token">0</span><span class="token">;</span><span>i</span><span class="token">&lt;</span><span>size</span><span class="token">;</span><span class="token">++</span><span>i</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>            par</span><span class="token">[</span><span class="token">0</span><span class="token">]</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">=</span><span>parent</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span>        
</span><span><span>        </span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> i</span><span class="token">=</span><span class="token">1</span><span class="token">;</span><span>i</span><span class="token">&lt;</span><span>maxDepth</span><span class="token">;</span><span class="token">++</span><span>i</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>            </span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> j</span><span class="token">=</span><span class="token">0</span><span class="token">;</span><span>j</span><span class="token">&lt;</span><span>size</span><span class="token">;</span><span class="token">++</span><span>j</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>                </span><span class="token">int</span><span> paren</span><span class="token">=</span><span>par</span><span class="token">[</span><span>i</span><span class="token">-</span><span class="token">1</span><span class="token">]</span><span class="token">[</span><span>j</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>                </span><span class="token">if</span><span class="token">(</span><span>paren</span><span class="token">!=</span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span> par</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">[</span><span>j</span><span class="token">]</span><span class="token">=</span><span>par</span><span class="token">[</span><span>i</span><span class="token">-</span><span class="token">1</span><span class="token">]</span><span class="token">[</span><span>paren</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>            </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span>        
</span><span><span>    </span><span class="token">}</span><span>
</span></span><span>        
</span><span><span>    </span><span class="token">int</span><span> </span><span class="token">getKthAncestor</span><span class="token">(</span><span class="token">int</span><span> node</span><span class="token">,</span><span> </span><span class="token">int</span><span> k</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> i</span><span class="token">=</span><span class="token">0</span><span class="token">;</span><span>i</span><span class="token">&lt;</span><span>maxDepth</span><span class="token">;</span><span class="token">++</span><span>i</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>            </span><span class="token">if</span><span class="token">(</span><span>k</span><span class="token">&amp;</span><span class="token">(</span><span class="token">1</span><span class="token">&lt;&lt;</span><span>i</span><span class="token">)</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>                node</span><span class="token">=</span><span>par</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">[</span><span>node</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>                </span><span class="token">if</span><span class="token">(</span><span>node</span><span class="token">==</span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span> </span><span class="token">return</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">;</span><span>
</span></span><span><span>            </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">return</span><span> node</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span class="token">;</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<p><a href="https://leetcode.com/problems/kth-ancestor-of-a-tree-node/discuss/686268/Explanation-with-c%2B%2B-sample-code" target="_blank">https://leetcode.com/problems/kth-ancestor-of-a-tree-node/discuss/686268/Explanation-with-c%2B%2B-sample-code</a></p>
<p><strong>Subtrees and paths</strong><br/>
A <strong>tree traversal array</strong> contains the nodes of a rooted tree in the order in whicha depth-first search from the root node visits them.<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/3263c4de-6f01-493a-9ebf-8c690544ee54_1626602709.9466834.png"/><br/><br/>
<strong>Subtree queries</strong><br/>
Each subtree of a tree corresponds to a subarray of the tree traversal array suchthat the first element of the subarray is the root node.<br/>
For example, the following subarray contains the nodes of the subtree of node 4:<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/145822dd-d74f-44e1-930e-07242b3f986b_1626602922.3231308.png"/><br/>Using this fact, we can efficiently process queries that are related to subtrees of a tree.</p>
<p><strong>Subtree Queries</strong><br/>
Consider the following tree where the blue numbers are the values of thenodes. For example, the sum of the subtree of node 4 is 3+4+3+1=11.<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/b1c96cfc-0bf2-433e-bf21-96825c250066_1626603670.8512366.png"/><br/>The idea is to construct a tree traversal array that contains three values foreach node: the identifier of the node, the size of the subtree, and the value of thenode. For example,<img alt="image" src="https://assets.leetcode.com/users/images/2b4ebd4c-6a6a-4065-ab4d-add8950516d9_1626603758.7182693.png"/><br/>Using this array, we can calculate the sum of values in any subtree by firstfinding out the size of the subtree and then the values of the corresponding nodes.For example, the values in the subtree of node 4 can be found as follows:<img alt="image" src="https://assets.leetcode.com/users/images/539f3415-dede-4138-b620-d71880ad06a6_1626603830.8824298.png"/><br/>To answer the queries efficiently, it suffices to store the values of the nodes in a<strong>binary indexed or segment tree</strong>. After this, we can both update a value and calculate the sum of values in O(logn) time</p>
<p><strong>Path queries</strong><br/>
Using a tree traversal array, we can also efficiently calculate sums of values on paths from the root node to any node of the tree. Consider a problem where our task is to support the following queries:•  change the value of a node calculate the sum of values on a path from the root to a node</p>
<p>When the value of a node increases byx, the sums of all nodes in its subtreeincrease byx.  For example, if the value of node 4 increases by 1, the arraychanges as follows:<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/7df2acaa-2a1e-4196-9f5e-d5aacc7cdc07_1626604036.216008.png"/><br/>Thus, to support both the operations, we should be able to increase all valuesin a range and retrieve a single value. This can be done in O(logn) time using a<strong>binary indexed or segment tree</strong> .</p>
<p>What is the sum of values on a path between two nodes?<br/>
What is the sum of values in the subtree of a node?</p>
<p><strong>Lowest common ancestor</strong><br/>
Method based on tree traversal array.</p>
<p>We <strong>add each node to the array always when the depth-first search walks through the node,and not only at the first visit</strong> (EULER TOUR). Hence, a node that has k children appears k+1 times in the array and there are a total of 2n−1 nodes in the array.<br/>
We store two values in the array: the identifier of the node and the depth ofthe node in the tree.Now we can find the <strong>lowest common ancestor of nodes a and b by finding the node with the minimum depth between nodes a and b in the array</strong>.</p>
<p>For example,the lowest common ancestor of nodes 5 and 8 can be found as follows:<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/d9af93ec-73d0-4e60-a87d-2791d235d200_1626604439.0447714.png"/><br/>Node 5 is at position 2, node 8 is at position 5, and the node with minimum depth between positions 2. . .5 is node 2 at position 3 whose depth is 2. Thus, the lowest common ancestor of nodes 5 and 8 is node 2.Thus, to find the lowest common ancestor of two nodes it suffices to process a<strong>range minimum query</strong>. Thus, the LCA problem is reduced to the RMQ problem.</p>
<p><strong>Implementation</strong> : <a href="https://cp-algorithms.com/graph/lca.html" target="_blank">https://cp-algorithms.com/graph/lca.html</a></p>
<p>What is the lowest common ancestor of two nodes?</p>
<hr/>
<details>
<summary>Advanced Concepts</summary>
<br/>
<p><strong>Heavy-Light Decomposition</strong><br/>
<a href="https://leetcode.com/tag/tree/discuss/1631485/Heavy-Light-Decomposition" target="_blank">https://leetcode.com/tag/tree/discuss/1631485/Heavy-Light-Decomposition</a></p>
<p>Used for the following type of operations on a tree -</p>
<ul>
<li>Update all nodes along the path from node x to node y.</li>
<li>Find the sum, maximum, minimum (or any other operation that satisfies the associative property) along the path from node x to node y.</li>
</ul>
<br/>
<hr/>
<p><strong>Centroid Decomposition</strong><br/>
<a href="https://www.geeksforgeeks.org/centroid-decomposition-of-tree/" target="_blank">https://www.geeksforgeeks.org/centroid-decomposition-of-tree/</a><br/>
<a href="https://usaco.guide/plat/centroid?lang=cpp" target="_blank">https://usaco.guide/plat/centroid?lang=cpp</a><br/>
<a href="https://www.youtube.com/watch?v=3pk02p1-weU" target="_blank">https://www.youtube.com/watch?v=3pk02p1-weU</a></p>
<h5 id="centroid"><strong>Centroid</strong></h5>
<p><code>Node whose removal guarantee largest remaining subtree is as small as possible.</code></p>
<p><code>Centroid of a Tree is a node which if removed from the tree would split it into a 'forest', such that any tree in the forest would have at most half the number of vertices in the original tree(n/2).</code></p>
<p><strong>Finding a Centroid</strong><br/>
We can find a centroid in a tree by starting at the root. Each step, loop through all of its children. If all of its children have subtree size less than or equal to n/2, then it is a centroid. Otherwise, move to the child with a subtree size that is more than n/2 and repeat until you find a centroid.</p>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">int</span><span> </span><span class="token">get_centroid</span><span class="token">(</span><span class="token">int</span><span> x</span><span class="token">,</span><span> </span><span class="token">int</span><span> par</span><span class="token">,</span><span> </span><span class="token">int</span><span> n</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>	</span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">:</span><span> adj</span><span class="token">[</span><span>x</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		</span><span class="token">if</span><span> </span><span class="token">(</span><span>i </span><span class="token">==</span><span> par</span><span class="token">)</span><span> </span><span class="token">continue</span><span class="token">;</span><span>
</span></span><span><span>		</span><span class="token">if</span><span> </span><span class="token">(</span><span>st_size</span><span class="token">[</span><span>i</span><span class="token">]</span><span> </span><span class="token">*</span><span> </span><span class="token">2</span><span> </span><span class="token">&gt;</span><span> n</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>			</span><span class="token">return</span><span> </span><span class="token">get_centroid</span><span class="token">(</span><span>i</span><span class="token">,</span><span> x</span><span class="token">,</span><span>n</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>		</span><span class="token">}</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span>	</span><span class="token">return</span><span> x</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<details>
<summary>Subtree size using dfs</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">int</span><span> </span><span class="token">dfs</span><span class="token">(</span><span class="token">int</span><span> x</span><span class="token">,</span><span> </span><span class="token">int</span><span> p</span><span class="token">)</span><span>
</span></span><span><span></span><span class="token">{</span><span>
</span></span><span><span>	st_size</span><span class="token">[</span><span>x</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> i</span><span class="token">:</span><span>adj</span><span class="token">[</span><span>x</span><span class="token">]</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>		</span><span class="token">if</span><span class="token">(</span><span>i</span><span class="token">==</span><span>p</span><span class="token">)</span><span> </span><span class="token">continue</span><span class="token">;</span><span>
</span></span><span><span>		st_size</span><span class="token">[</span><span>x</span><span class="token">]</span><span> </span><span class="token">+=</span><span> </span><span class="token">dfs</span><span class="token">(</span><span>i</span><span class="token">,</span><span>x</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span>	</span><span class="token">return</span><span> st_size</span><span class="token">[</span><span>x</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<br/>
</details>
<hr/>
<p><strong>DSU on tree</strong><br/>
<a href="https://usaco.guide/plat/merging?lang=cpp" target="_blank">https://usaco.guide/plat/merging?lang=cpp</a></p>
<br/>
</details>
<hr/></div></div></div>