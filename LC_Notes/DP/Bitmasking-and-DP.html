<div class="break-words"><div><div class="FN9Jv WRmCx"><p>Bit operations provide an efficient and convenient way to implement dynamic programming algorithms whose states contain subsets of elements, because such states can be stored as integers.</p>
<p><strong>Optimal selection</strong><br/>
Consider the following problem: We are given the prices of k products over n days, and we want to buy each product exactly once. However, we are allowed to buy at most one product in a day. What is the minimum total price?</p>
<p>let total ( S, d ) denote the minimum total price for buying a subset S of products by day d and price [ x ][ d ] denote the price of product x on day d. Then, the following recurrence can be used:</p>
<blockquote>
<p>total ( S, d ) = min( total ( S, d − 1), min<sub>x ∈ S</sub> ( total ( S \ x, d − 1) + price [ x ][ d ]))</p>
</blockquote>
<p>This means that we either do not buy any product on day d or buy a product x that belongs to S . In the latter case, we remove x from S and add the price of x to the total price.</p>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">int</span><span> total</span><span class="token">[</span><span class="token">1</span><span class="token">&lt;&lt;</span><span>K</span><span class="token">]</span><span class="token">[</span><span>N</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span>
</span><span><span></span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> x </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span> x </span><span class="token">&lt;</span><span> k</span><span class="token">;</span><span> x</span><span class="token">++</span><span class="token">)</span><span> </span><span class="token">{</span><span>              </span><span class="token">// the cases where d = 0</span><span>
</span></span><span><span>	total</span><span class="token">[</span><span class="token">1</span><span class="token">&lt;&lt;</span><span>x</span><span class="token">]</span><span class="token">[</span><span class="token">0</span><span class="token">]</span><span> </span><span class="token">=</span><span> price</span><span class="token">[</span><span>x</span><span class="token">]</span><span class="token">[</span><span class="token">0</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">}</span><span>
</span></span><span>
</span><span><span></span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> d </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span> d </span><span class="token">&lt;</span><span> n</span><span class="token">;</span><span> d</span><span class="token">++</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>    </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> s </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span> s </span><span class="token">&lt;</span><span> </span><span class="token">(</span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> k</span><span class="token">)</span><span class="token">;</span><span> s</span><span class="token">++</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>        total</span><span class="token">[</span><span>s</span><span class="token">]</span><span class="token">[</span><span>d</span><span class="token">]</span><span> </span><span class="token">=</span><span> total</span><span class="token">[</span><span>s</span><span class="token">]</span><span class="token">[</span><span>d </span><span class="token">-</span><span> </span><span class="token">1</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> x </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span> x </span><span class="token">&lt;</span><span> k</span><span class="token">;</span><span> x</span><span class="token">++</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>            </span><span class="token">if</span><span> </span><span class="token">(</span><span>s </span><span class="token">&amp;</span><span> </span><span class="token">(</span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> x</span><span class="token">)</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>                total</span><span class="token">[</span><span>s</span><span class="token">]</span><span class="token">[</span><span>d</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">min</span><span class="token">(</span><span>total</span><span class="token">[</span><span>s</span><span class="token">]</span><span class="token">[</span><span>d</span><span class="token">]</span><span class="token">,</span><span> total</span><span class="token">[</span><span>s </span><span class="token">^</span><span> </span><span class="token">(</span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> x</span><span class="token">)</span><span class="token">]</span><span class="token">[</span><span>d </span><span class="token">-</span><span> </span><span class="token">1</span><span class="token">]</span><span> </span><span class="token">+</span><span> price</span><span class="token">[</span><span>x</span><span class="token">]</span><span class="token">[</span><span>d</span><span class="token">]</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>            </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<h3 id="from-permutations-to-subsets"><strong>From permutations to subsets</strong></h3>
<p>Using dynamic programming, it is often possible to change an iteration over permutations into an iteration over subsets 1 . The benefit of this is that n !, the number of permutations, is much larger than 2 n , the number of subsets. For example, if n = 20, then n ! ≈ 2.4 · 10 18 and 2 n ≈ 10 6 . Thus, for certain values of n ,we can efficiently go through the subsets but not through the permutations.</p>
<p>Consider the following problem: There is an elevator with maximum weight x , and n people with known weights who want to get from the ground floor to the top floor. What is the minimum number of rides needed if the people enter the elevator in an optimal order?</p>
<blockquote>
<p>Problem Link : <a href="https://cses.fi/problemset/task/1653/" target="_blank">https://cses.fi/problemset/task/1653/</a></p>
</blockquote>
<details>
<summary>Idea and time complexity</summary>
<br/>
The problem can be easily solved in O ( n ! n ) time by testing all possible permutations of n people.   However, we can use dynamic programming to get a more efficient O (2<sup>n</sup> n ) time algorithm. The idea is to calculate for each subset of people two values: the minimum number of rides needed and the minimum weight of people who ride in the last group.
<br/>
</details>
<br/>
<details>
<summary>Idea Implementation Explanation</summary>
<br/>
Let weight [ p ] denote the weight of person p . We define two functions: rides ( S ) is the minimum number of rides for a subset S , and last ( S ) is the minimum weight of the last ride. For example, in the above scenario rides 
&gt;({1, 3, 4}) = 2 and last ({1, 3, 4}) = 5, 
because the optimal rides are {1, 4} and {3}, and the second ride has weight 5. Of course, our final goal is to calculate the value of rides ({0 . . . n − 1}).
We can calculate the values of the functions recursively and then apply dynamic programming. The idea is to go through all people who belong to S and optimally choose the last person p who enters the elevator. Each such choice yields a subproblem for a smaller subset of people. If last ( S \ p ) + weight [ p ] ≤ x , we can add p to the last ride. Otherwise, we have to reserve a new ride that initially only contains p .
<br/>
</details>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span>pair</span><span class="token">&lt;</span><span class="token">int</span><span class="token">,</span><span> </span><span class="token">int</span><span class="token">&gt;</span><span> best</span><span class="token">[</span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> N</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>best</span><span class="token">[</span><span class="token">0</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">{</span><span class="token">1</span><span class="token">,</span><span> </span><span class="token">0</span><span class="token">}</span><span class="token">;</span><span>
</span></span><span>
</span><span><span></span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> s </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span> s </span><span class="token">&lt;</span><span> </span><span class="token">(</span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> n</span><span class="token">)</span><span class="token">;</span><span> s</span><span class="token">++</span><span class="token">)</span><span>
</span></span><span><span></span><span class="token">{</span><span>
</span></span><span><span>    best</span><span class="token">[</span><span>s</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">{</span><span>n </span><span class="token">+</span><span> </span><span class="token">1</span><span class="token">,</span><span> </span><span class="token">0</span><span class="token">}</span><span class="token">;</span><span>                            </span><span class="token">// initial value: n+1 rides are needed</span><span>
</span></span><span><span>    </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> p </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span> p </span><span class="token">&lt;</span><span> n</span><span class="token">;</span><span> p</span><span class="token">++</span><span class="token">)</span><span>
</span></span><span><span>    </span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span>s </span><span class="token">&amp;</span><span> </span><span class="token">(</span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> p</span><span class="token">)</span><span class="token">)</span><span>
</span></span><span><span>        </span><span class="token">{</span><span>
</span></span><span><span>            </span><span class="token">auto</span><span> option </span><span class="token">=</span><span> best</span><span class="token">[</span><span>s </span><span class="token">^</span><span> </span><span class="token">(</span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> p</span><span class="token">)</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>            </span><span class="token">if</span><span> </span><span class="token">(</span><span>option</span><span class="token">.</span><span>second </span><span class="token">+</span><span> weight</span><span class="token">[</span><span>p</span><span class="token">]</span><span> </span><span class="token">&lt;=</span><span> x</span><span class="token">)</span><span>      </span><span class="token">// add p to an existing ride</span><span>
</span></span><span><span>            </span><span class="token">{</span><span>
</span></span><span><span>                option</span><span class="token">.</span><span>second </span><span class="token">+=</span><span> weight</span><span class="token">[</span><span>p</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>            </span><span class="token">}</span><span>
</span></span><span><span>            </span><span class="token">else</span><span>                                     </span><span class="token">// reserve a new ride for p</span><span>
</span></span><span><span>            </span><span class="token">{</span><span>
</span></span><span><span>                option</span><span class="token">.</span><span>first</span><span class="token">++</span><span class="token">;</span><span>
</span></span><span><span>                option</span><span class="token">.</span><span>second </span><span class="token">=</span><span> weight</span><span class="token">[</span><span>p</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>            </span><span class="token">}</span><span>
</span></span><span><span>            best</span><span class="token">[</span><span>s</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">min</span><span class="token">(</span><span>best</span><span class="token">[</span><span>s</span><span class="token">]</span><span class="token">,</span><span> option</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<p>Note that the above loop guarantees that for any two subsets S1 and S2 such that S1 ⊂ S2 , we process S1 before S2 . Thus, the dynamic programming values are calculated in the correct order.</p>
<hr/>
<p><strong>Count ways to assign unique cap to every person <a href="https://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/?ref=rp" target="_blank">GFG-link</a> <a href="https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/" target="_blank">LC Link</a></strong></p>
<details>
<summary>Approach</summary>
<br/>
Suppose we have a collection of elements which are numbered from 1 to N. If we want to represent a subset of this set then it can be encoded by a sequence of N bits (we usually call this sequence a mask). In our chosen subset the i-th element belongs to it if and only if the i-th bit of the mask is set.
Our main methodology is to assign a value to each mask (and, therefore, to each subset) and thus calculate the values for new masks using values of the already computed masks.
To find the value for a subset X we remove an element in every possible way and use values for obtained subsets X’1, X’2… ,X’k to compute the value/solution for X. 
<br/>
</details>
<br/>
<details>
<summary>Code Implementation</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">class</span><span> </span><span class="token">Solution</span><span> </span><span class="token">{</span><span>
</span></span><span><span></span><span class="token">public</span><span class="token">:</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> </span><span class="token">numberWays</span><span class="token">(</span><span>vector</span><span class="token">&lt;</span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;&gt;</span><span class="token">&amp;</span><span> hats</span><span class="token">)</span><span> </span><span class="token">{</span><span>              </span><span class="token">// hats[people][hat]</span><span>
</span></span><span><span>        </span><span class="token">const</span><span> </span><span class="token">int</span><span> kBase </span><span class="token">=</span><span> </span><span class="token">1000000007</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">const</span><span> </span><span class="token">int</span><span> nhats </span><span class="token">=</span><span> </span><span class="token">40</span><span class="token">;</span><span>                                </span><span class="token">// Max number of hats</span><span>
</span></span><span><span>        </span><span class="token">const</span><span> </span><span class="token">int</span><span> n </span><span class="token">=</span><span> hats</span><span class="token">.</span><span class="token">size</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>                           </span><span class="token">// Number of people.</span><span>
</span></span><span>                
</span><span><span>        vector</span><span class="token">&lt;</span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;&gt;</span><span> </span><span class="token">h2p</span><span class="token">(</span><span>nhats </span><span class="token">+</span><span> </span><span class="token">1</span><span class="token">)</span><span class="token">;</span><span>                  </span><span class="token">// we are given hats set for a people we are calculation people set for a hat</span><span>
</span></span><span><span>        </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span> i </span><span class="token">&lt;</span><span> n</span><span class="token">;</span><span> i</span><span class="token">++</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>            </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> h </span><span class="token">:</span><span> hats</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>                h2p</span><span class="token">[</span><span>h</span><span class="token">]</span><span class="token">.</span><span class="token">push_back</span><span class="token">(</span><span>i</span><span class="token">)</span><span class="token">;</span><span>                        </span><span class="token">// h2p[hat][people]</span><span>
</span></span><span><span>            </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span>        
</span><span><span>        </span><span class="token">// dp[h][subset] = #ways of making sure each person from |subset| has a hat from 1, 2, ... h (compatible to their wishes).</span><span>
</span></span><span><span>        </span><span class="token">// NOTE: one can reduce the space complexity by keeping only the last two rows, but current implementation is easier to understand.</span><span>
</span></span><span>		
</span><span><span>        </span><span class="token">const</span><span> </span><span class="token">int</span><span> num_subsets </span><span class="token">=</span><span> </span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> n</span><span class="token">;</span><span>                                  </span><span class="token">// total subset possible for n people</span><span>
</span></span><span><span>        vector</span><span class="token">&lt;</span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;&gt;</span><span> </span><span class="token">dp</span><span class="token">(</span><span>nhats </span><span class="token">+</span><span> </span><span class="token">1</span><span class="token">,</span><span> </span><span class="token generic-function">vector</span><span class="token generic-function generic">&lt;</span><span class="token generic-function generic">int</span><span class="token generic-function generic">&gt;</span><span class="token">(</span><span>num_subsets</span><span class="token">,</span><span> </span><span class="token">0</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>  </span><span class="token">// dp[hat][subset] </span><span>
</span></span><span><span>        dp</span><span class="token">[</span><span class="token">0</span><span class="token">]</span><span class="token">[</span><span class="token">0</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span>                                                    </span><span class="token">// one empty assignment.</span><span>
</span></span><span>        
</span><span><span>		</span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> h </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span> h </span><span class="token">&lt;=</span><span> nhats</span><span class="token">;</span><span> h</span><span class="token">++</span><span class="token">)</span><span> </span><span class="token">{</span><span>                         
</span></span><span><span>            </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> s </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span> s </span><span class="token">&lt;</span><span> num_subsets</span><span class="token">;</span><span> s</span><span class="token">++</span><span class="token">)</span><span> </span><span class="token">{</span><span>                    </span><span class="token">// For each subset s of people</span><span>
</span></span><span>                
</span><span><span>                </span><span class="token">// Dont' use this hat</span><span>
</span></span><span><span>                dp</span><span class="token">[</span><span>h</span><span class="token">]</span><span class="token">[</span><span>s</span><span class="token">]</span><span> </span><span class="token">+=</span><span> dp</span><span class="token">[</span><span>h</span><span class="token">-</span><span class="token">1</span><span class="token">]</span><span class="token">[</span><span>s</span><span class="token">]</span><span class="token">;</span><span>                               </span><span class="token">// s is a subset i.e. it represent on of the possible  configuration</span><span>
</span></span><span><span>                dp</span><span class="token">[</span><span>h</span><span class="token">]</span><span class="token">[</span><span>s</span><span class="token">]</span><span> </span><span class="token">%=</span><span> kBase</span><span class="token">;</span><span>
</span></span><span>                
</span><span><span>               </span><span class="token">// Use this hat on available persons who prefer it</span><span>
</span></span><span><span>                </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">const</span><span> </span><span class="token">int</span><span> p </span><span class="token">:</span><span> h2p</span><span class="token">[</span><span>h</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>                    </span><span class="token">const</span><span> </span><span class="token">int</span><span> mask </span><span class="token">=</span><span> </span><span class="token">1</span><span> </span><span class="token">&lt;&lt;</span><span> p</span><span class="token">;</span><span>              </span><span class="token">// bitmask the pth person</span><span>
</span></span><span><span>                    </span><span class="token">if</span><span> </span><span class="token">(</span><span class="token">(</span><span>s </span><span class="token">&amp;</span><span> mask</span><span class="token">)</span><span> </span><span class="token">!=</span><span> </span><span class="token">0</span><span class="token">)</span><span> </span><span class="token">{</span><span>                </span><span class="token">// if pth person is in s</span><span>
</span></span><span><span>                        dp</span><span class="token">[</span><span>h</span><span class="token">]</span><span class="token">[</span><span>s</span><span class="token">]</span><span> </span><span class="token">+=</span><span> dp</span><span class="token">[</span><span>h</span><span class="token">-</span><span class="token">1</span><span class="token">]</span><span class="token">[</span><span>s </span><span class="token">^</span><span> mask</span><span class="token">]</span><span class="token">;</span><span>    </span><span class="token">// s^mask will remove the person p from bitmask s</span><span>
</span></span><span><span>                        dp</span><span class="token">[</span><span>h</span><span class="token">]</span><span class="token">[</span><span>s</span><span class="token">]</span><span> </span><span class="token">%=</span><span> kBase</span><span class="token">;</span><span>
</span></span><span><span>                    </span><span class="token">}</span><span>
</span></span><span><span>                </span><span class="token">}</span><span>
</span></span><span><span>            </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">//  ways of making sure each person from 0, 1, ... n-1 has a hat from 1, 2, ... nhats</span><span>
</span></span><span><span>        </span><span class="token">return</span><span> dp</span><span class="token">[</span><span>nhats</span><span class="token">]</span><span class="token">[</span><span>num_subsets </span><span class="token">-</span><span> </span><span class="token">1</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span class="token">;</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<br/>
</details>
<p><strong>Maximum Students Taking Exam <a href="https://leetcode.com/problems/maximum-students-taking-exam/discuss/503686/a-simple-tutorial-on-this-bitmasking-problem" target="_blank">Tutorial for learning bitmask dp based on this problem</a></strong><br/>
<strong>Partition to K Equal Sum Subsets <a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/335668/dynamic-programming-with-bit-masking-solution-best-for-interviews" target="_blank">Tutorial for learning bitmask dp based on this problem</a></strong></p>
<p>More Problems -<br/>
<a href="https://leetcode.com/tag/bitmask/" target="_blank">https://leetcode.com/tag/bitmask/</a></p></div></div></div>