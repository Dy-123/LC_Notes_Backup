<div class="break-words"><div><div class="FN9Jv WRmCx"><p><strong>House Robber III</strong></p>
<blockquote>
<p>Problem Link: <a href="https://leetcode.com/problems/house-robber-iii/" target="_blank">https://leetcode.com/problems/house-robber-iii/</a></p>
</blockquote>
<details>
<summary>Approach</summary>
<br/>
<p>For every node we have two choices<br/>
i) choose to rob the node<br/>
ii) choose not to rob node</p>
<details>
<summary>Approach 1</summary>
<br/>
<p>For every node we have two choices<br/>
i) choose to rob the node =&gt; we cann't rob the child node but we can rob its grand-child node<br/>
ii) choose not to rob node =&gt; we can rob the child node</p>
<p><img alt="image" src="https://assets.leetcode.com/users/images/edc96675-415c-4dc5-9591-2912ddbc970d_1655834498.8394263.png"/><br/></p>
<p>Let A be node on which we are exercising our choices then<br/>
i) we can choose to rob A =&gt; we cann't rob B and C but we can rob D, E,F and G<br/>
ii) we choose not to rob A =&gt; we can rob B and C</p>
<p>By recursively solving max(choice i , choice ii ) we will get the max possible answer of all the possibilities.</p>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-dart" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">Let</span><span class="token">,</span><span> root </span><span class="token">=</span><span class="token">&gt;</span><span> the node </span><span class="token">on</span><span> which we are making choice </span><span class="token">(</span><span class="token">in</span><span> above tree it </span><span class="token">is</span><span> </span><span class="token">*</span><span class="token">*</span><span class="token">A</span><span class="token">*</span><span class="token">*</span><span class="token">)</span><span>
</span></span><span><span>l </span><span class="token">=</span><span class="token">&gt;</span><span> left child </span><span class="token">(</span><span class="token">*</span><span class="token">*</span><span class="token">B</span><span class="token">*</span><span class="token">*</span><span class="token">)</span><span> </span><span class="token">|</span><span> r </span><span class="token">=</span><span class="token">&gt;</span><span> right child </span><span class="token">(</span><span class="token">*</span><span class="token">*</span><span class="token">C</span><span class="token">*</span><span class="token">*</span><span class="token">)</span><span> </span><span class="token">|</span><span> ll </span><span class="token">=</span><span class="token">&gt;</span><span> left child of l </span><span class="token">(</span><span class="token">*</span><span class="token">*</span><span class="token">D</span><span class="token">*</span><span class="token">*</span><span class="token">)</span><span> </span><span class="token">|</span><span> lr </span><span class="token">=</span><span class="token">&gt;</span><span> right child of l </span><span class="token">(</span><span class="token">*</span><span class="token">*</span><span class="token">E</span><span class="token">*</span><span class="token">*</span><span class="token">)</span><span> </span><span class="token">|</span><span> rl </span><span class="token">=</span><span class="token">&gt;</span><span> left child of r </span><span class="token">(</span><span class="token">*</span><span class="token">*</span><span class="token">F</span><span class="token">*</span><span class="token">*</span><span class="token">)</span><span> </span><span class="token">|</span><span> rr </span><span class="token">=</span><span class="token">&gt;</span><span> right child of r </span><span class="token">(</span><span class="token">*</span><span class="token">*</span><span class="token">G</span><span class="token">*</span><span class="token">*</span><span class="token">)</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<p>Then we can write our choice as<br/>
i) (root-&gt;val) +rob(lr)+rob(ll)+rob(rl)+rob(rr)<br/>
ii) rob(l)+rob(r)</p>
<p>Now we have to recursively solve  max(root-&gt;val+rob(lr)+rob(ll)+rob(rl)+rob(rr),rob(l)+rob(r)) and we will get max of all possible possibilities.</p>
</details>
</details>
<br/>
<details>
<summary>Recursive Implementation 1</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">class</span><span> </span><span class="token">Solution</span><span> </span><span class="token">{</span><span>
</span></span><span><span></span><span class="token">public</span><span class="token">:</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> </span><span class="token">rob</span><span class="token">(</span><span>TreeNode</span><span class="token">*</span><span> root</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>root</span><span class="token">==</span><span class="token">nullptr</span><span class="token">)</span><span> </span><span class="token">return</span><span> </span><span class="token">0</span><span class="token">;</span><span>
</span></span><span><span>        TreeNode </span><span class="token">*</span><span>l</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>r</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>ll</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>lr</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>rl</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>rr</span><span class="token">=</span><span class="token">nullptr</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">!=</span><span class="token">nullptr</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>            l</span><span class="token">=</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">;</span><span>
</span></span><span><span>            lr</span><span class="token">=</span><span>l</span><span class="token">-&gt;</span><span>right</span><span class="token">;</span><span>
</span></span><span><span>            ll</span><span class="token">=</span><span>l</span><span class="token">-&gt;</span><span>left</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">!=</span><span class="token">nullptr</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>            r</span><span class="token">=</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">;</span><span>
</span></span><span><span>            rl</span><span class="token">=</span><span>r</span><span class="token">-&gt;</span><span>left</span><span class="token">;</span><span>
</span></span><span><span>            rr</span><span class="token">=</span><span>r</span><span class="token">-&gt;</span><span>right</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">return</span><span> </span><span class="token">max</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>val</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>lr</span><span class="token">)</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>ll</span><span class="token">)</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>rl</span><span class="token">)</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>rr</span><span class="token">)</span><span class="token">,</span><span class="token">rob</span><span class="token">(</span><span>l</span><span class="token">)</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>r</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span class="token">;</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<br/>
</details>
<details>
<summary>Recursive Implementation 2</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-kotlin" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">class</span><span> Solution </span><span class="token">{</span><span>
</span></span><span><span></span><span class="token">public</span><span class="token">:</span><span>
</span></span><span>    
</span><span><span>    int </span><span class="token">rob</span><span class="token">(</span><span>TreeNode</span><span class="token">*</span><span> root</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">return</span><span> </span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span>    
</span><span><span>    int </span><span class="token">solve</span><span class="token">(</span><span>TreeNode</span><span class="token">*</span><span> root</span><span class="token">,</span><span>int prvRob</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">if</span><span class="token">(</span><span class="token">!</span><span>root</span><span class="token">)</span><span> </span><span class="token">return</span><span> </span><span class="token">0</span><span class="token">;</span><span>
</span></span><span>                
</span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>prvRob</span><span class="token">==</span><span class="token">0</span><span class="token">)</span><span>
</span></span><span><span>            </span><span class="token">return</span><span> </span><span class="token">max</span><span class="token">(</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">,</span><span class="token">1</span><span class="token">)</span><span class="token">+</span><span>root</span><span class="token">-&gt;</span><span class="token">val</span><span class="token">+</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">,</span><span class="token">1</span><span class="token">)</span><span class="token">,</span><span>                                                                       </span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">+</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">else</span><span class="token">{</span><span>
</span></span><span><span>              </span><span class="token">return</span><span> </span><span class="token">(</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">+</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span>        
</span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span class="token">;</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
</details>
<p>Memorization of Recursive Implementation (DP)<br/>
The pointer values to nodes will not be contiguos therefore it is preferred to use non contiguos like data structure ( like map or unordered map) to memorise and since we do not need the ordering of key and for faster performance we are using unordered map to memorise the choices on nodes.</p>
<details>
<summary>DP Implementation 1</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">class</span><span> </span><span class="token">Solution</span><span> </span><span class="token">{</span><span>
</span></span><span><span></span><span class="token">public</span><span class="token">:</span><span>
</span></span><span><span>    unordered_map</span><span class="token">&lt;</span><span>TreeNode</span><span class="token">*</span><span class="token">,</span><span class="token">int</span><span class="token">&gt;</span><span>mp</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> </span><span class="token">rob</span><span class="token">(</span><span>TreeNode</span><span class="token">*</span><span> root</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>root</span><span class="token">==</span><span class="token">nullptr</span><span class="token">)</span><span> </span><span class="token">return</span><span> </span><span class="token">0</span><span class="token">;</span><span>
</span></span><span><span>        TreeNode </span><span class="token">*</span><span>l</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>r</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>ll</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>lr</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>rl</span><span class="token">=</span><span class="token">nullptr</span><span class="token">,</span><span class="token">*</span><span>rr</span><span class="token">=</span><span class="token">nullptr</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">!=</span><span class="token">nullptr</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>            l</span><span class="token">=</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">;</span><span>
</span></span><span><span>            lr</span><span class="token">=</span><span>l</span><span class="token">-&gt;</span><span>right</span><span class="token">;</span><span>
</span></span><span><span>            ll</span><span class="token">=</span><span>l</span><span class="token">-&gt;</span><span>left</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">!=</span><span class="token">nullptr</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>            r</span><span class="token">=</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">;</span><span>
</span></span><span><span>            rl</span><span class="token">=</span><span>r</span><span class="token">-&gt;</span><span>left</span><span class="token">;</span><span>
</span></span><span><span>            rr</span><span class="token">=</span><span>r</span><span class="token">-&gt;</span><span>right</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span>        
</span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>mp</span><span class="token">.</span><span class="token">find</span><span class="token">(</span><span>root</span><span class="token">)</span><span class="token">!=</span><span>mp</span><span class="token">.</span><span class="token">end</span><span class="token">(</span><span class="token">)</span><span class="token">)</span><span> </span><span class="token">return</span><span> mp</span><span class="token">[</span><span>root</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span>        
</span><span><span>        </span><span class="token">return</span><span> mp</span><span class="token">[</span><span>root</span><span class="token">]</span><span class="token">=</span><span class="token">max</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>val</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>lr</span><span class="token">)</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>ll</span><span class="token">)</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>rl</span><span class="token">)</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>rr</span><span class="token">)</span><span class="token">,</span><span class="token">rob</span><span class="token">(</span><span>l</span><span class="token">)</span><span class="token">+</span><span class="token">rob</span><span class="token">(</span><span>r</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span class="token">;</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
</details>
<details>
<summary>DP Implementation 2</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">class</span><span> </span><span class="token">Solution</span><span> </span><span class="token">{</span><span>
</span></span><span><span></span><span class="token">public</span><span class="token">:</span><span>
</span></span><span>    
</span><span><span>    unordered_map</span><span class="token">&lt;</span><span>TreeNode</span><span class="token">*</span><span class="token">,</span><span> vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;&gt;</span><span>mp</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> </span><span class="token">rob</span><span class="token">(</span><span>TreeNode</span><span class="token">*</span><span> root</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">return</span><span> </span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span>    
</span><span><span>    </span><span class="token">int</span><span> </span><span class="token">solve</span><span class="token">(</span><span>TreeNode</span><span class="token">*</span><span> root</span><span class="token">,</span><span class="token">int</span><span> prvRob</span><span class="token">)</span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">if</span><span class="token">(</span><span class="token">!</span><span>root</span><span class="token">)</span><span> </span><span class="token">return</span><span> </span><span class="token">0</span><span class="token">;</span><span>
</span></span><span>        
</span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>mp</span><span class="token">.</span><span class="token">count</span><span class="token">(</span><span>root</span><span class="token">)</span><span> </span><span class="token">&amp;&amp;</span><span> mp</span><span class="token">[</span><span>root</span><span class="token">]</span><span class="token">[</span><span>prvRob</span><span class="token">]</span><span> </span><span class="token">!=</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span> </span><span class="token">return</span><span> mp</span><span class="token">[</span><span>root</span><span class="token">]</span><span class="token">[</span><span>prvRob</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>        mp</span><span class="token">[</span><span>root</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">{</span><span class="token">-</span><span class="token">1</span><span class="token">,</span><span class="token">-</span><span class="token">1</span><span class="token">}</span><span class="token">;</span><span>    </span><span class="token">// add two values inside vector</span><span>
</span></span><span>        
</span><span><span>        </span><span class="token">if</span><span class="token">(</span><span>prvRob</span><span class="token">==</span><span class="token">0</span><span class="token">)</span><span>
</span></span><span><span>            </span><span class="token">return</span><span> mp</span><span class="token">[</span><span>root</span><span class="token">]</span><span class="token">[</span><span>prvRob</span><span class="token">]</span><span class="token">=</span><span> </span><span class="token">max</span><span class="token">(</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">,</span><span class="token">1</span><span class="token">)</span><span class="token">+</span><span>root</span><span class="token">-&gt;</span><span>val</span><span class="token">+</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">,</span><span class="token">1</span><span class="token">)</span><span class="token">,</span><span>                                                                       </span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">+</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">else</span><span class="token">{</span><span>
</span></span><span><span>              </span><span class="token">return</span><span> mp</span><span class="token">[</span><span>root</span><span class="token">]</span><span class="token">[</span><span>prvRob</span><span class="token">]</span><span class="token">=</span><span> </span><span class="token">(</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>left</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">+</span><span class="token">solve</span><span class="token">(</span><span>root</span><span class="token">-&gt;</span><span>right</span><span class="token">,</span><span class="token">0</span><span class="token">)</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span>        
</span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span class="token">;</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
</details>
<hr/>
<p><strong>Given a tree with N nodes and N-1 edges, calculate the maximum sum of the node values from root to any of the leaves without re-visiting any node.</strong></p>
<blockquote>
<p>GFG Tutorial: <a href="https://www.geeksforgeeks.org/dynamic-programming-trees-set-1/" target="_blank">https://www.geeksforgeeks.org/dynamic-programming-trees-set-1/</a></p>
</blockquote>
<details>
<summary>Code</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">int</span><span> dp</span><span class="token">[</span><span class="token">100</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">void</span><span> </span><span class="token">dfs</span><span class="token">(</span><span class="token">int</span><span> a</span><span class="token">[</span><span class="token">]</span><span class="token">,</span><span> vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> v</span><span class="token">[</span><span class="token">]</span><span class="token">,</span><span> </span><span class="token">int</span><span> u</span><span class="token">,</span><span> </span><span class="token">int</span><span> parent</span><span class="token">)</span><span>                   </span><span class="token">// function for dfs traversal and to store the maximum value in dp[] for every node till the leaves</span><span>
</span></span><span><span></span><span class="token">{</span><span>
</span></span><span><span>    dp</span><span class="token">[</span><span>u</span><span class="token">]</span><span> </span><span class="token">=</span><span> a</span><span class="token">[</span><span>u </span><span class="token">-</span><span> </span><span class="token">1</span><span class="token">]</span><span class="token">;</span><span>                                                   </span><span class="token">// initially dp[u] is always a[u]</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> maximum </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span>                                                    </span><span class="token">// stores the maximum value from nodes</span><span>
</span></span><span> 
</span><span><span>    </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> child </span><span class="token">:</span><span> v</span><span class="token">[</span><span>u</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span>child </span><span class="token">==</span><span> parent</span><span class="token">)</span><span> </span><span class="token">continue</span><span class="token">;</span><span>                                  </span><span class="token">// if child is parent, then we continue without recursing further</span><span>
</span></span><span><span>        </span><span class="token">dfs</span><span class="token">(</span><span>a</span><span class="token">,</span><span> v</span><span class="token">,</span><span> child</span><span class="token">,</span><span> u</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>        maximum </span><span class="token">=</span><span> </span><span class="token">max</span><span class="token">(</span><span>maximum</span><span class="token">,</span><span> dp</span><span class="token">[</span><span>child</span><span class="token">]</span><span class="token">)</span><span class="token">;</span><span>                              </span><span class="token">// store the maximum of previous visited node and present visited node</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span>    dp</span><span class="token">[</span><span>u</span><span class="token">]</span><span> </span><span class="token">+=</span><span> maximum</span><span class="token">;</span><span>                                                   </span><span class="token">// add the maximum value returned to the parent node</span><span>
</span></span><span><span></span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">// dp[1] have the maximum value</span><span>
</span></span><span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<br/>
</details>
<br/>
<hr/>
<p><strong>Given a tree with N nodes and N-1 edges, find out the maximum height of the tree when any node in the tree is considered as the root of the tree.</strong></p>
<blockquote>
<p>GFG Tutorial: <a href="https://www.geeksforgeeks.org/dynamic-programming-trees-set-2/" target="_blank">https://www.geeksforgeeks.org/dynamic-programming-trees-set-2/</a><br/>
USACO Tutorial: <a href="https://usaco.guide/gold/dp-trees?lang=cpp" target="_blank">https://usaco.guide/gold/dp-trees?lang=cpp</a></p>
</blockquote>
<p>A naive approach would be to traverse the tree using DFS traversal for every node and calculate the maximum height when the node is treated as the root of the tree. The time complexity for the DFS traversal of a tree is O(N). The overall time complexity of DFS for all N nodes will be O(N)*N i.e., O(N^2).</p>
<p>To solve this problem, pre-calculate two things for every node. One will be the maximum height while traveling downwards via its branches to the leaves. While the other will be the maximum height when traveling upwards via its parent to any of the leaves.</p>
<p><strong>in[i]</strong> =&gt; maximum height of the tree when we travel downwards via its sub-trees and leaves.<br/>
<strong>out[i]</strong> =&gt; maximum height of the tree while traveling upwards via its parent.</p>
<p>The maximum height of a tree when node i is considered as a root will be max(in[i], out[i]).</p>
<p>Calculation of in[i]:<br/>
<img alt="image" src="https://assets.leetcode.com/users/images/abc2d392-f139-4431-abc0-ab9e3870c222_1629654628.5604372.png"/><br/>Traverse the tree using DFS and calculate in[i] as max(in[i], 1+in[child]) for every node.</p>
<p>Calculation of out[i]:<br/>
out[i] = 1 + max(out[parent of i], 1 + longest path of all branches of parent of i)</p>
<details>
<summary>Code</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-csharp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">int</span><span> </span><span class="token">in</span><span class="token">[</span><span>MAX_NODES</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">int</span><span> </span><span class="token">out</span><span class="token">[</span><span>MAX_NODES</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span></span><span class="token return-type">void</span><span> </span><span class="token">dfs1</span><span class="token">(</span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> v</span><span class="token">[</span><span class="token">]</span><span class="token">,</span><span> </span><span class="token">int</span><span> u</span><span class="token">,</span><span> </span><span class="token">int</span><span> parent</span><span class="token">)</span><span>                      </span><span class="token">// function to pre-calculate the array in[] which stores the maximum height when travelled via branches</span><span>
</span></span><span><span></span><span class="token">{</span><span>
</span></span><span><span>    </span><span class="token">in</span><span class="token">[</span><span>u</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span>                                                    </span><span class="token">// initially every node has 0 height</span><span>
</span></span><span>    
</span><span><span>	</span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> child </span><span class="token">:</span><span> v</span><span class="token">[</span><span>u</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">{</span><span>                                      </span><span class="token">// traverse in the subtree of u</span><span>
</span></span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span>child </span><span class="token">==</span><span> parent</span><span class="token">)</span><span> </span><span class="token">continue</span><span class="token">;</span><span>                           </span><span class="token">// if child is same as parent</span><span>
</span></span><span><span>        </span><span class="token">dfs1</span><span class="token">(</span><span>v</span><span class="token">,</span><span> child</span><span class="token">,</span><span> u</span><span class="token">)</span><span class="token">;</span><span>                                       </span><span class="token">// dfs called</span><span>
</span></span><span><span>        </span><span class="token">in</span><span class="token">[</span><span>u</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">max</span><span class="token">(</span><span class="token">in</span><span class="token">[</span><span>u</span><span class="token">]</span><span class="token">,</span><span> </span><span class="token">1</span><span> </span><span class="token">+</span><span> </span><span class="token">in</span><span class="token">[</span><span>child</span><span class="token">]</span><span class="token">)</span><span class="token">;</span><span>                      </span><span class="token">// recursively calculate the max height</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span>
</span></span><span> 
</span><span><span></span><span class="token return-type">void</span><span> </span><span class="token">dfs2</span><span class="token">(</span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> v</span><span class="token">[</span><span class="token">]</span><span class="token">,</span><span> </span><span class="token">int</span><span> u</span><span class="token">,</span><span> </span><span class="token">int</span><span> parent</span><span class="token">)</span><span>                    </span><span class="token">// function to pre-calculate the array ouut[] which stores the maximum height when traveled via parent</span><span>
</span></span><span><span></span><span class="token">{</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> mx1 </span><span class="token">=</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">,</span><span> mx2 </span><span class="token">=</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">;</span><span>                                     </span><span class="token">// stores the longest and second longest branches</span><span>
</span></span><span>    
</span><span><span>	</span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> child </span><span class="token">:</span><span> v</span><span class="token">[</span><span>u</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">{</span><span>                                    </span><span class="token">// traverse in the subtress of u</span><span>
</span></span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span>child </span><span class="token">==</span><span> parent</span><span class="token">)</span><span> </span><span class="token">continue</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span class="token">in</span><span class="token">[</span><span>child</span><span class="token">]</span><span> </span><span class="token">&gt;=</span><span> mx1</span><span class="token">)</span><span> </span><span class="token">{</span><span>                                </span><span class="token">// compare and store the longest and second longest</span><span>
</span></span><span><span>            mx2 </span><span class="token">=</span><span> mx1</span><span class="token">;</span><span>
</span></span><span><span>            mx1 </span><span class="token">=</span><span> </span><span class="token">in</span><span class="token">[</span><span>child</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>        </span><span class="token">else</span><span> </span><span class="token">if</span><span> </span><span class="token">(</span><span class="token">in</span><span class="token">[</span><span>child</span><span class="token">]</span><span> </span><span class="token">&gt;</span><span> mx2</span><span class="token">)</span><span> mx2 </span><span class="token">=</span><span> </span><span class="token">in</span><span class="token">[</span><span>child</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span> 
</span><span><span>    </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> child </span><span class="token">:</span><span> v</span><span class="token">[</span><span>u</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">{</span><span>                                    </span><span class="token">// traverse in the subtree of u</span><span>
</span></span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span>child </span><span class="token">==</span><span> parent</span><span class="token">)</span><span> </span><span class="token">continue</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">int</span><span> longest </span><span class="token">=</span><span> mx1</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span>mx1 </span><span class="token">==</span><span> </span><span class="token">in</span><span class="token">[</span><span>child</span><span class="token">]</span><span class="token">)</span><span> longest </span><span class="token">=</span><span> mx2</span><span class="token">;</span><span>                   </span><span class="token">// if longest branch has the node, then consider the second longest branch</span><span>
</span></span><span><span>        </span><span class="token">out</span><span class="token">[</span><span>child</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">1</span><span> </span><span class="token">+</span><span> </span><span class="token">max</span><span class="token">(</span><span class="token">out</span><span class="token">[</span><span>u</span><span class="token">]</span><span class="token">,</span><span> </span><span class="token">1</span><span> </span><span class="token">+</span><span> longest</span><span class="token">)</span><span class="token">;</span><span>             </span><span class="token">// recursively calculate out[i]</span><span>
</span></span><span><span>        </span><span class="token">dfs2</span><span class="token">(</span><span>v</span><span class="token">,</span><span> child</span><span class="token">,</span><span> u</span><span class="token">)</span><span class="token">;</span><span>                                     </span><span class="token">// dfs function call</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span>
</span></span><span> 
</span><span><span></span><span class="token return-type">void</span><span> </span><span class="token">printHeights</span><span class="token">(</span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> v</span><span class="token">[</span><span class="token">]</span><span class="token">,</span><span> </span><span class="token">int</span><span> n</span><span class="token">)</span><span>                     </span><span class="token">// function to print all the maximum heights from every node</span><span>
</span></span><span><span></span><span class="token">{</span><span>
</span></span><span><span>    </span><span class="token">dfs1</span><span class="token">(</span><span>v</span><span class="token">,</span><span> </span><span class="token">1</span><span class="token">,</span><span> </span><span class="token">0</span><span class="token">)</span><span class="token">;</span><span>                                            </span><span class="token">// traversal to calculate in[] array</span><span>
</span></span><span><span>    </span><span class="token">dfs2</span><span class="token">(</span><span>v</span><span class="token">,</span><span> </span><span class="token">1</span><span class="token">,</span><span> </span><span class="token">0</span><span class="token">)</span><span class="token">;</span><span>                                            </span><span class="token">// traversal to calculate out[] array</span><span>
</span></span><span> 
</span><span><span>    </span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span> i </span><span class="token">&lt;=</span><span> n</span><span class="token">;</span><span> i</span><span class="token">++</span><span class="token">)</span><span>
</span></span><span><span>        cout </span><span class="token">&lt;&lt;</span><span> </span><span class="token">"The maximum height when node "</span><span class="token">&lt;&lt;</span><span> i </span><span class="token">&lt;&lt;</span><span> </span><span class="token">" is considered as root"</span><span class="token">&lt;&lt;</span><span> </span><span class="token">" is "</span><span> </span><span class="token">&lt;&lt;</span><span> </span><span class="token">max</span><span class="token">(</span><span class="token">in</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">,</span><span> </span><span class="token">out</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">)</span><span class="token">&lt;&lt;</span><span> </span><span class="token">"\n"</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<br/>
</details>
<br/>
<hr/>
<p><strong>Given an N-ary tree T of N nodes, the task is to calculate the longest path between any two nodes(also known as the diameter of the tree).</strong></p>
<blockquote>
<p>GFG Tutorial: <a href="https://www.geeksforgeeks.org/dp-on-trees-set-3-diameter-of-n-ary-tree/" target="_blank">https://www.geeksforgeeks.org/dp-on-trees-set-3-diameter-of-n-ary-tree/</a></p>
</blockquote>
<p>For diamter there are two possibility -</p>
<p><strong>Case 1 :</strong> Let's say that there exist a node x such that the longest path starts from node x and goes into its subtree and ends at some node in the subtree itself. Lets define this path length by dp1[x].<br/>
<strong>dp1[node] will be equal to 1 + max(dp1[children1], dp1[children2], ..).</strong></p>
<p><strong>Case 2 :</strong> Suppose the diameter or the longest path starts in subtree of a node x, passes through it and ends in it's subtree. Let's define this path by dp2[x].</p>
<p>If for all nodes x, we take a maximum of dp1[x], dp2[x], then we will get the diameter of the tree.</p>
<details>
<summary>Code</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-java" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token">int</span><span> diameter </span><span class="token">=</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">;</span><span>
</span></span><span>
</span><span><span></span><span class="token">int</span><span> </span><span class="token">dfs</span><span class="token">(</span><span class="token">int</span><span> node</span><span class="token">,</span><span> </span><span class="token">int</span><span> parent</span><span class="token">,</span><span> </span><span class="token">int</span><span> dp1</span><span class="token">[</span><span class="token">]</span><span class="token">,</span><span> </span><span class="token">int</span><span> dp2</span><span class="token">[</span><span class="token">]</span><span class="token">,</span><span> list</span><span class="token generics">&lt;</span><span class="token generics">int</span><span class="token generics">&gt;</span><span class="token">*</span><span> adj</span><span class="token">)</span><span>          </span><span class="token">// Function to find the diameter of the tree using Dynamic Programming</span><span>
</span></span><span><span></span><span class="token">{</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> firstmax </span><span class="token">=</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">;</span><span>                                                       </span><span class="token">// Store the first maximum and secondmax</span><span>
</span></span><span><span>    </span><span class="token">int</span><span> secondmax </span><span class="token">=</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span>    </span><span class="token">for</span><span> </span><span class="token">(</span><span>auto i </span><span class="token">=</span><span> adj</span><span class="token">[</span><span>node</span><span class="token">]</span><span class="token">.</span><span class="token">begin</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span> i </span><span class="token">!=</span><span> adj</span><span class="token">[</span><span>node</span><span class="token">]</span><span class="token">.</span><span class="token">end</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span> </span><span class="token">++</span><span>i</span><span class="token">)</span><span> </span><span class="token">{</span><span>            </span><span class="token">// Traverse for all children of node</span><span>
</span></span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span class="token">*</span><span>i </span><span class="token">==</span><span> parent</span><span class="token">)</span><span> </span><span class="token">continue</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span>        </span><span class="token">dfs</span><span class="token">(</span><span class="token">*</span><span>i</span><span class="token">,</span><span> node</span><span class="token">,</span><span> dp1</span><span class="token">,</span><span> dp2</span><span class="token">,</span><span> adj</span><span class="token">)</span><span class="token">;</span><span>                                        </span><span class="token">// Call DFS function again</span><span>
</span></span><span> 
</span><span><span>        </span><span class="token">if</span><span> </span><span class="token">(</span><span>firstmax </span><span class="token">==</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span> firstmax </span><span class="token">=</span><span> dp1</span><span class="token">[</span><span class="token">*</span><span>i</span><span class="token">]</span><span class="token">;</span><span>                              </span><span class="token">// Find first max</span><span>
</span></span><span><span>        </span><span class="token">else</span><span> </span><span class="token">if</span><span> </span><span class="token">(</span><span>dp1</span><span class="token">[</span><span class="token">*</span><span>i</span><span class="token">]</span><span> </span><span class="token">&gt;=</span><span> firstmax</span><span class="token">)</span><span>                                        </span><span class="token">// Secondmaximum</span><span>
</span></span><span><span>        </span><span class="token">{</span><span>
</span></span><span><span>            secondmax </span><span class="token">=</span><span> firstmax</span><span class="token">;</span><span>
</span></span><span><span>            firstmax </span><span class="token">=</span><span> dp1</span><span class="token">[</span><span class="token">*</span><span>i</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>		</span><span class="token">else</span><span> </span><span class="token">if</span><span> </span><span class="token">(</span><span>dp1</span><span class="token">[</span><span class="token">*</span><span>i</span><span class="token">]</span><span> </span><span class="token">&gt;</span><span> secondmax</span><span class="token">)</span><span>                                        </span><span class="token">// Find secondmaximum</span><span>
</span></span><span><span>        </span><span class="token">{</span><span>
</span></span><span><span>            secondmax </span><span class="token">=</span><span> dp1</span><span class="token">[</span><span class="token">*</span><span>i</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>        </span><span class="token">}</span><span>
</span></span><span><span>    </span><span class="token">}</span><span>
</span></span><span> 
</span><span><span>    dp1</span><span class="token">[</span><span>node</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span>                                                          </span><span class="token">// Base case for every node</span><span>
</span></span><span><span>    </span><span class="token">if</span><span> </span><span class="token">(</span><span>firstmax </span><span class="token">!=</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span> dp1</span><span class="token">[</span><span>node</span><span class="token">]</span><span> </span><span class="token">+=</span><span> firstmax</span><span class="token">;</span><span>                              </span><span class="token">// Add</span><span>
</span></span><span><span>    </span><span class="token">if</span><span> </span><span class="token">(</span><span>secondmax </span><span class="token">!=</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span> dp2</span><span class="token">[</span><span>node</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">1</span><span> </span><span class="token">+</span><span> firstmax </span><span class="token">+</span><span> secondmax</span><span class="token">;</span><span>              </span><span class="token">// Find dp[2]</span><span>
</span></span><span><span>    </span><span class="token">return</span><span> </span><span class="token">max</span><span class="token">(</span><span>dp1</span><span class="token">[</span><span>node</span><span class="token">]</span><span class="token">,</span><span> dp2</span><span class="token">[</span><span>node</span><span class="token">]</span><span class="token">)</span><span class="token">;</span><span>                                       </span><span class="token">// Return maximum of both</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
</details>
<details>
<summary> Non-DP Approach </summary>
<br/>
<p>One easy to implement solution is using 2 Breadth First Searches (BFS). Start a BFS with a random node and store the last node encountered before search ends. This last node will definitely be one of the ends of the diameter (Why?). Now run a second BFS from this node and you will end on the other end of the diameter.</p>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token macro directive-hash">#</span><span class="token macro directive">include</span><span class="token macro">&lt;bits/stdc++.h&gt;</span><span>
</span></span><span><span></span><span class="token">using</span><span> </span><span class="token">namespace</span><span> std</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token macro directive-hash">#</span><span class="token macro directive">define</span><span class="token macro"> </span><span class="token macro macro-name">SZ</span><span class="token macro"> </span><span class="token macro expression">200005</span><span>
</span></span><span> 
</span><span><span></span><span class="token">int</span><span> n</span><span class="token">,</span><span> m</span><span class="token">,</span><span> x</span><span class="token">,</span><span> y</span><span class="token">;</span><span> 
</span></span><span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> adj</span><span class="token">[</span><span>SZ</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span>pair</span><span class="token">&lt;</span><span class="token">int</span><span class="token">,</span><span class="token">int</span><span class="token">&gt;</span><span> </span><span class="token">bfs</span><span class="token">(</span><span class="token">int</span><span> src</span><span class="token">)</span><span>
</span></span><span><span></span><span class="token">{</span><span>
</span></span><span><span>	</span><span class="token">int</span><span> d </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span>
</span></span><span><span>	queue</span><span class="token">&lt;</span><span>pair</span><span class="token">&lt;</span><span class="token">int</span><span class="token">,</span><span class="token">int</span><span class="token">&gt;</span><span> </span><span class="token">&gt;</span><span> q</span><span class="token">;</span><span>
</span></span><span><span>	q</span><span class="token">.</span><span class="token">push</span><span class="token">(</span><span class="token">{</span><span>src</span><span class="token">,</span><span> </span><span class="token">0</span><span class="token">}</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	vector</span><span class="token">&lt;</span><span class="token">bool</span><span class="token">&gt;</span><span> </span><span class="token">vis</span><span class="token">(</span><span>SZ</span><span class="token">,</span><span> </span><span class="token">false</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	pair</span><span class="token">&lt;</span><span class="token">int</span><span class="token">,</span><span class="token">int</span><span class="token">&gt;</span><span>  u</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span>	</span><span class="token">while</span><span class="token">(</span><span class="token">!</span><span>q</span><span class="token">.</span><span class="token">empty</span><span class="token">(</span><span class="token">)</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		u </span><span class="token">=</span><span> q</span><span class="token">.</span><span class="token">front</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>		vis</span><span class="token">[</span><span>u</span><span class="token">.</span><span>first</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">true</span><span class="token">;</span><span>
</span></span><span><span>		q</span><span class="token">.</span><span class="token">pop</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>		</span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> v</span><span class="token">:</span><span> adj</span><span class="token">[</span><span>u</span><span class="token">.</span><span>first</span><span class="token">]</span><span class="token">)</span><span>
</span></span><span><span>			</span><span class="token">if</span><span class="token">(</span><span class="token">!</span><span>vis</span><span class="token">[</span><span>v</span><span class="token">]</span><span class="token">)</span><span>
</span></span><span><span>			q</span><span class="token">.</span><span class="token">push</span><span class="token">(</span><span class="token">{</span><span>v</span><span class="token">,</span><span> u</span><span class="token">.</span><span>second </span><span class="token">+</span><span> </span><span class="token">1</span><span class="token">}</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span>	</span><span class="token">return</span><span> u</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">}</span><span>
</span></span><span> 
</span><span><span></span><span class="token">int</span><span> </span><span class="token">main</span><span class="token">(</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>	cin </span><span class="token">&gt;&gt;</span><span> n</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span> i </span><span class="token">&lt;</span><span> n</span><span class="token">-</span><span class="token">1</span><span class="token">;</span><span> i</span><span class="token">++</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		cin </span><span class="token">&gt;&gt;</span><span> x </span><span class="token">&gt;&gt;</span><span> y</span><span class="token">;</span><span>
</span></span><span><span>		adj</span><span class="token">[</span><span>x</span><span class="token">]</span><span class="token">.</span><span class="token">push_back</span><span class="token">(</span><span>y</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>		adj</span><span class="token">[</span><span>y</span><span class="token">]</span><span class="token">.</span><span class="token">push_back</span><span class="token">(</span><span>x</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span>	pair</span><span class="token">&lt;</span><span class="token">int</span><span class="token">,</span><span class="token">int</span><span class="token">&gt;</span><span>  end1 </span><span class="token">=</span><span> </span><span class="token">bfs</span><span class="token">(</span><span class="token">1</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	pair</span><span class="token">&lt;</span><span class="token">int</span><span class="token">,</span><span class="token">int</span><span class="token">&gt;</span><span>  end2 </span><span class="token">=</span><span> </span><span class="token">bfs</span><span class="token">(</span><span>end1</span><span class="token">.</span><span>first</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	cout </span><span class="token">&lt;&lt;</span><span> end2</span><span class="token">.</span><span>second </span><span class="token">&lt;&lt;</span><span> endl</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
</details>
<hr/>
<p><strong>Tree Distance I</strong></p>
<blockquote>
<p>Problem Link: <a href="https://cses.fi/problemset/task/1132" target="_blank">https://cses.fi/problemset/task/1132</a><br/>
USACO Tutorial: <a href="https://usaco.guide/gold/all-roots?lang=cpp" target="_blank">https://usaco.guide/gold/all-roots?lang=cpp</a></p>
</blockquote>
<blockquote>
<p>You are given a tree consisting of n nodes. Your task is to determine for each node the maximum distance to another node.</p>
</blockquote>
<p>For each node, we want to calculate maximum distance to another node. Previously we saw that that if we start a BFS from any node, we end up on either of the diametric end. We can use this fact to efficiently compute the answer. Let's calculate distances of each node from both the ends of the diameter. Then maximum distance of each node can be calculated as:<br/>
<strong>max_distance[u] = max(distance_from_diametric_end1[u], distance_from_diametric_end2[u])</strong></p>
<details>
<summary>Code</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token macro directive-hash">#</span><span class="token macro directive">include</span><span class="token macro">&lt;bits/stdc++.h&gt;</span><span>
</span></span><span><span></span><span class="token">using</span><span> </span><span class="token">namespace</span><span> std</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token macro directive-hash">#</span><span class="token macro directive">define</span><span class="token macro"> </span><span class="token macro macro-name">SZ</span><span class="token macro"> </span><span class="token macro expression">200005</span><span>
</span></span><span> 
</span><span><span></span><span class="token">int</span><span> n</span><span class="token">,</span><span> m</span><span class="token">,</span><span> k</span><span class="token">,</span><span> x</span><span class="token">;</span><span>
</span></span><span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> adj</span><span class="token">[</span><span>SZ</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> </span><span class="token">ans</span><span class="token">(</span><span>SZ</span><span class="token">,</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span></span><span class="token">int</span><span> </span><span class="token">bfs</span><span class="token">(</span><span class="token">int</span><span> src</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>	</span><span class="token">int</span><span> top</span><span class="token">;</span><span>
</span></span><span><span>	queue</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> q</span><span class="token">;</span><span>
</span></span><span><span>	vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> </span><span class="token">d</span><span class="token">(</span><span>n</span><span class="token">+</span><span class="token">1</span><span class="token">,</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	d</span><span class="token">[</span><span>src</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span>
</span></span><span><span>	ans</span><span class="token">[</span><span>src</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">max</span><span class="token">(</span><span>ans</span><span class="token">[</span><span>src</span><span class="token">]</span><span class="token">,</span><span> d</span><span class="token">[</span><span>src</span><span class="token">]</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	q</span><span class="token">.</span><span class="token">push</span><span class="token">(</span><span>src</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span>	</span><span class="token">while</span><span class="token">(</span><span class="token">!</span><span>q</span><span class="token">.</span><span class="token">empty</span><span class="token">(</span><span class="token">)</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		top </span><span class="token">=</span><span> q</span><span class="token">.</span><span class="token">front</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>		q</span><span class="token">.</span><span class="token">pop</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span>		</span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> v</span><span class="token">:</span><span> adj</span><span class="token">[</span><span>top</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>			</span><span class="token">if</span><span class="token">(</span><span>d</span><span class="token">[</span><span>v</span><span class="token">]</span><span> </span><span class="token">==</span><span> </span><span class="token">-</span><span class="token">1</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>				q</span><span class="token">.</span><span class="token">push</span><span class="token">(</span><span>v</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>				d</span><span class="token">[</span><span>v</span><span class="token">]</span><span> </span><span class="token">=</span><span> d</span><span class="token">[</span><span>top</span><span class="token">]</span><span> </span><span class="token">+</span><span> </span><span class="token">1</span><span class="token">;</span><span>
</span></span><span><span>				ans</span><span class="token">[</span><span>v</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">max</span><span class="token">(</span><span>ans</span><span class="token">[</span><span>v</span><span class="token">]</span><span class="token">,</span><span> d</span><span class="token">[</span><span>v</span><span class="token">]</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>			</span><span class="token">}</span><span>
</span></span><span><span>		</span><span class="token">}</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span>	</span><span class="token">return</span><span> top</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">}</span><span>
</span></span><span> 
</span><span><span></span><span class="token">int</span><span> </span><span class="token">main</span><span class="token">(</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>	</span><span class="token">int</span><span> u</span><span class="token">,</span><span> v</span><span class="token">;</span><span>
</span></span><span>	
</span><span><span>	cin </span><span class="token">&gt;&gt;</span><span> n</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">;</span><span> i </span><span class="token">&lt;</span><span> n</span><span class="token">-</span><span class="token">1</span><span class="token">;</span><span> i</span><span class="token">++</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		cin </span><span class="token">&gt;&gt;</span><span> u </span><span class="token">&gt;&gt;</span><span> v</span><span class="token">;</span><span>
</span></span><span><span>		adj</span><span class="token">[</span><span>u</span><span class="token">]</span><span class="token">.</span><span class="token">push_back</span><span class="token">(</span><span>v</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>		adj</span><span class="token">[</span><span>v</span><span class="token">]</span><span class="token">.</span><span class="token">push_back</span><span class="token">(</span><span>u</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span>	</span><span class="token">int</span><span> diam_end_1 </span><span class="token">=</span><span> </span><span class="token">bfs</span><span class="token">(</span><span class="token">1</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">int</span><span> diam_end_2 </span><span class="token">=</span><span> </span><span class="token">bfs</span><span class="token">(</span><span>diam_end_1</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">bfs</span><span class="token">(</span><span>diam_end_2</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span> 
</span><span><span>	</span><span class="token">for</span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span> i </span><span class="token">&lt;=</span><span>n </span><span class="token">;</span><span> i</span><span class="token">++</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		cout </span><span class="token">&lt;&lt;</span><span> ans</span><span class="token">[</span><span>i</span><span class="token">]</span><span> </span><span class="token">&lt;&lt;</span><span> </span><span class="token">" "</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
<p><a href="https://www.geeksforgeeks.org/farthest-distance-of-a-node-from-each-node-of-a-tree/?ref=rp" target="_blank">https://www.geeksforgeeks.org/farthest-distance-of-a-node-from-each-node-of-a-tree/?ref=rp</a><br/>
<a href="https://usaco.guide/problems/cses-1132-tree-distances-i/solution/#solution-1" target="_blank">https://usaco.guide/problems/cses-1132-tree-distances-i/solution/#solution-1</a><br/>
<a href="https://github.com/kartik8800/CSES/blob/master/Tree%20Distances%201" target="_blank">https://github.com/kartik8800/CSES/blob/master/Tree%20Distances%201</a></p>
<br/>
</details>
<hr/>
<p><strong>Tree Distance II</strong></p>
<blockquote>
<p>Problem Link: <a href="https://cses.fi/problemset/task/1133" target="_blank">https://cses.fi/problemset/task/1133</a><br/>
USACO Tutorial: <a href="https://usaco.guide/problems/cses-1133-tree-distances-ii/solution" target="_blank">https://usaco.guide/problems/cses-1133-tree-distances-ii/solution</a></p>
</blockquote>
<blockquote>
<p>You are given a tree consisting of n nodes. Your task is to determine for each node the sum of the distances from the node to all other nodes.</p>
</blockquote>
<details>
<summary>Code</summary>
<br/>
<div class="mb-6 rounded-lg px-3 py-2.5 font-menlo text-sm bg-fill-3 dark:bg-dark-fill-3"><div class="group relative" translate="no"><pre style=" font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent;"><code class="language-cpp" style=' font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none;'><span><span class="token macro directive-hash">#</span><span class="token macro directive">include</span><span class="token macro"> </span><span class="token macro">&lt;bits/stdc++.h&gt;</span><span>
</span></span><span><span></span><span class="token">using</span><span> </span><span class="token">namespace</span><span> std</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">typedef</span><span> </span><span class="token">long</span><span> </span><span class="token">long</span><span> ll</span><span class="token">;</span><span>
</span></span><span>
</span><span><span></span><span class="token">int</span><span> n</span><span class="token">;</span><span>
</span></span><span><span>vector</span><span class="token">&lt;</span><span class="token">int</span><span class="token">&gt;</span><span> graph</span><span class="token">[</span><span class="token">200001</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>ll dp</span><span class="token">[</span><span class="token">200001</span><span class="token">]</span><span class="token">,</span><span> ans</span><span class="token">[</span><span class="token">200001</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span>
</span><span><span></span><span class="token">void</span><span> </span><span class="token">dfs1</span><span class="token">(</span><span class="token">int</span><span> node </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">,</span><span> </span><span class="token">int</span><span> parent </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">,</span><span> ll depth </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>	ans</span><span class="token">[</span><span class="token">1</span><span class="token">]</span><span> </span><span class="token">+=</span><span> depth</span><span class="token">;</span><span>
</span></span><span><span>	dp</span><span class="token">[</span><span>node</span><span class="token">]</span><span> </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">:</span><span> graph</span><span class="token">[</span><span>node</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">if</span><span> </span><span class="token">(</span><span>i </span><span class="token">!=</span><span> parent</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		</span><span class="token">dfs1</span><span class="token">(</span><span>i</span><span class="token">,</span><span> node</span><span class="token">,</span><span> depth </span><span class="token">+</span><span> </span><span class="token">1</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>		dp</span><span class="token">[</span><span>node</span><span class="token">]</span><span> </span><span class="token">+=</span><span> dp</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span>
</span></span><span>
</span><span><span></span><span class="token">void</span><span> </span><span class="token">dfs2</span><span class="token">(</span><span class="token">int</span><span> node </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">,</span><span> </span><span class="token">int</span><span> parent </span><span class="token">=</span><span> </span><span class="token">0</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>	</span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">:</span><span> graph</span><span class="token">[</span><span>node</span><span class="token">]</span><span class="token">)</span><span> </span><span class="token">if</span><span> </span><span class="token">(</span><span>i </span><span class="token">!=</span><span> parent</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		ans</span><span class="token">[</span><span>i</span><span class="token">]</span><span> </span><span class="token">=</span><span> ans</span><span class="token">[</span><span>node</span><span class="token">]</span><span> </span><span class="token">+</span><span> n </span><span class="token">-</span><span> </span><span class="token">2</span><span> </span><span class="token">*</span><span> dp</span><span class="token">[</span><span>i</span><span class="token">]</span><span class="token">;</span><span>
</span></span><span><span>		</span><span class="token">dfs2</span><span class="token">(</span><span>i</span><span class="token">,</span><span> node</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span></span><span class="token">}</span><span>
</span></span><span>
</span><span><span></span><span class="token">int</span><span> </span><span class="token">main</span><span class="token">(</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>	ios_base</span><span class="token double-colon">::</span><span class="token">sync_with_stdio</span><span class="token">(</span><span class="token">0</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	cin</span><span class="token">.</span><span class="token">tie</span><span class="token">(</span><span class="token">0</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	cin </span><span class="token">&gt;&gt;</span><span> n</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span> i </span><span class="token">&lt;</span><span> n</span><span class="token">;</span><span> i</span><span class="token">++</span><span class="token">)</span><span> </span><span class="token">{</span><span>
</span></span><span><span>		</span><span class="token">int</span><span> a</span><span class="token">,</span><span> b</span><span class="token">;</span><span>
</span></span><span><span>		cin </span><span class="token">&gt;&gt;</span><span> a </span><span class="token">&gt;&gt;</span><span> b</span><span class="token">;</span><span>
</span></span><span><span>		graph</span><span class="token">[</span><span>a</span><span class="token">]</span><span class="token">.</span><span class="token">push_back</span><span class="token">(</span><span>b</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>		graph</span><span class="token">[</span><span>b</span><span class="token">]</span><span class="token">.</span><span class="token">push_back</span><span class="token">(</span><span>a</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">}</span><span>
</span></span><span><span>	</span><span class="token">dfs1</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">dfs2</span><span class="token">(</span><span class="token">)</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">for</span><span> </span><span class="token">(</span><span class="token">int</span><span> i </span><span class="token">=</span><span> </span><span class="token">1</span><span class="token">;</span><span> i </span><span class="token">&lt;=</span><span> n</span><span class="token">;</span><span> i</span><span class="token">++</span><span class="token">)</span><span> cout </span><span class="token">&lt;&lt;</span><span> ans</span><span class="token">[</span><span>i</span><span class="token">]</span><span> </span><span class="token">&lt;&lt;</span><span> </span><span class="token">' '</span><span class="token">;</span><span>
</span></span><span><span>	</span><span class="token">return</span><span> </span><span class="token">0</span><span class="token">;</span><span>
</span></span><span><span></span><span class="token">}</span></span></code></pre><div class="absolute -right-1.5 -top-0.5 flex gap-2"><div class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"><div class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]" data-state="closed"><div><div data-state="closed"><div class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"></div></div></div></div></div></div></div></div>
</details>
<hr/>
<p><strong>Company Queries II and Distance Queries</strong><br/>
<strong>Based on Binary Jumping/ Successor graph concept (CPH 18.1 Finding Ancestor)</strong></p>
<p><a href="https://usaco.guide/plat/binary-jump?lang=cpp" target="_blank">https://usaco.guide/plat/binary-jump?lang=cpp</a></p>
<p>Company Queries I<br/>
<a href="https://medium.com/@sahilawasthi9560460170/lowest-common-ancestor-of-n-ary-tree-107fa772a939" target="_blank">https://medium.com/@sahilawasthi9560460170/lowest-common-ancestor-of-n-ary-tree-107fa772a939</a><br/>
<a href="https://cp-algorithms.com/graph/lca_binary_lifting.html" target="_blank">https://cp-algorithms.com/graph/lca_binary_lifting.html</a></p>
<p><strong>Counting Path</strong><br/>
<a href="https://youtu.be/8Nq3THy2Kw0?t=767" target="_blank">Video </a></p>
<p><strong>Subtree Queries</strong><br/>
<strong>Based on Euler Tour Technique</strong></p>
<p><strong>Path Queries I</strong><br/>
<strong>Based on Euler Tour Technique</strong><br/>
<a href="https://usaco.guide/problems/cses-1138-path-queries/solution" target="_blank">https://usaco.guide/problems/cses-1138-path-queries/solution</a></p>
<details>
<summary>Advanced Concept Problems</summary>
<br/>
<p><strong>Path Queries II</strong><br/>
<strong>Based on Heavy-Light Decomposition</strong><br/>
<a href="https://usaco.guide/problems/cses-2134-path-queries-ii/solution" target="_blank">https://usaco.guide/problems/cses-2134-path-queries-ii/solution</a></p>
<p><strong>Distinct Colors</strong><br/>
<strong>Based on Merging Data Structures</strong><br/>
<a href="https://usaco.guide/plat/merging?lang=cpp" target="_blank">https://usaco.guide/plat/merging?lang=cpp</a></p>
<p><strong>Finding a centroid</strong><br/>
<strong>Based on Centroid Decomposition</strong><br/>
<a href="https://usaco.guide/problems/cses-2079-finding-a-centroid/solution" target="_blank">https://usaco.guide/problems/cses-2079-finding-a-centroid/solution</a></p>
<p><strong>Fixed length path</strong><br/>
<strong>Based on Centroid Decomposition</strong><br/>
<a href="https://usaco.guide/problems/cses-2080-fixed-length-paths-i/solution" target="_blank">https://usaco.guide/problems/cses-2080-fixed-length-paths-i/solution</a><br/>
<a href="https://usaco.guide/problems/cses-2081-fixed-length-paths-ii/solution" target="_blank">https://usaco.guide/problems/cses-2081-fixed-length-paths-ii/solution</a></p>
</details>
<hr/>
<blockquote>
<p>Tutorial Link Of CSES Problems: <a href="https://codeforces.com/blog/entry/79048" target="_blank">https://codeforces.com/blog/entry/79048</a></p>
</blockquote></div></div></div>